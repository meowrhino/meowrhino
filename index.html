<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!--<title>Patrón de Puntos</title>-->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inknut+Antiqua:wght@300&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/styles.css">
  <script src="https://unpkg.com/paper"></script>
</head>

<body>
  <canvas id="canvas-nubes"></canvas>
  <div class="container--content"></div>
  <!-- Botón open fun, paleta, etc., aquí -->
  <button id="open-fun">open fun</button>
  <!-- ...paletas de colores aquí... -->
  <script>
    document.addEventListener("DOMContentLoaded", async function () {
  // --- Configuración base ---
  const NUM_VENTANAS = 5;   // Número de "pantallas" verticales
  const NUM_CUADRANTES_H = 1; // Divide horizontalmente cada ventana en 2 (left/right, tú eliges)

  // --- Datos de proyectos ---
  const proyectos = await fetch("proyectos.json").then(r => r.json());

  // --- DOM elements ---
  const container = document.querySelector(".container--content");
  const canvas = document.getElementById("canvas-nubes");

  // --- Coordenadas poligonales para el blob (clip-path en CSS, path en canvas) ---
  const nubeCSS = getComputedStyle(document.documentElement).getPropertyValue("--nube").trim();
  const nubeCoords = nubeCSS.replace(/^polygon\(|\)$/g, "")
    .split(",")
    .map(pt => pt.trim().split(" "))
    .map(([xs, ys]) => [parseFloat(xs) / 100, parseFloat(ys) / 100]);

  // --- 1. GENERA POSICIONES EN VENTANAS Y CUADRANTES ---
  // Cada palabra se coloca en su sección vertical (ventana) y, opcional, cuadrante horizontal (izq/der, centro...)
  function calculaPosiciones() {
    let secciones = Array.from({ length: NUM_VENTANAS }, () => []);
    proyectos.forEach((p, i) => secciones[i % NUM_VENTANAS].push(p));
    let posiciones = [];

    // Ajusta estos valores para personalizar la "aleatoriedad" y dispersión
    secciones.forEach((projs, vIdx) => {
      projs.forEach((p, i) => {
        // Divide horizontalmente (ej: 2 cuadrantes: left, right)
        const hIdx = i % NUM_CUADRANTES_H;
        const leftBase = (hIdx / NUM_CUADRANTES_H) * 100;
        const leftMax = ((hIdx + 1) / NUM_CUADRANTES_H) * 100;

        // Rango vertical SOLO dentro de su ventana
        const topBase = vIdx * 100;
        const top = topBase + 10 + Math.random() * 70; // 10-80vh dentro de cada ventana
        const left = leftBase + 5 + Math.random() * (leftMax - leftBase - 20); // deja margen lateral

        // Tamaño coherente, responsive
        const w = 18 + Math.random() * 9; // ancho en vw
        const h = w / 1.55 * (window.innerWidth / window.innerHeight);

        posiciones.push({ top, left, w, h, proyecto: p });
      });
    });
    return posiciones;
  }

  // --- 2. INICIALIZAR Paper.js Y AJUSTAR CANVAS ---
  function resizeCanvas() {
    // Canvas siempre igual de alto que las "ventanas"
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight * NUM_VENTANAS;
    paper.view.viewSize = new paper.Size(canvas.width, canvas.height);
  }
  paper.setup(canvas);
  resizeCanvas();

  // --- 3. DIBUJA LAS NUBES EN EL CANVAS, FUSIONA SI SE SOLAPAN ---
  function renderBlobs(posiciones) {
    paper.project.activeLayer.removeChildren();
    let blobs = [];

    posiciones.forEach(({ top, left, w, h }) => {
      // vh/vw a px (para el canvas)
      const x = (left / 100) * canvas.width;
      const y = (top / (NUM_VENTANAS * 100)) * canvas.height; // (top/500)*height si 5 ventanas
      const ancho = (w / 100) * canvas.width;
      const alto = (h / (NUM_VENTANAS * 100)) * canvas.height * NUM_VENTANAS; // Ajuste vertical para proporcionalidad

      // Crea path poligonal en Paper.js (misma forma que CSS)
      const path = new paper.Path();
      nubeCoords.forEach(([px, py], i) => {
        const pt = new paper.Point(x + px * ancho, y + py * alto);
        i === 0 ? path.moveTo(pt) : path.lineTo(pt);
      });
      path.closed = true;
      path.fillColor = getComputedStyle(document.documentElement).getPropertyValue("--color-2").trim();
      path.strokeColor = getComputedStyle(document.documentElement).getPropertyValue("--color-3").trim();
      path.strokeWidth = 8;
      path.shadowColor = new paper.Color(0, 0, 0, 0.24);
      path.shadowBlur = 24;

      blobs.push(path);
    });

    // --- FUSIONA BLOBS QUE SE TOCAN (como conjuntos) ---
    let fusionados = [];
    let usados = Array(blobs.length).fill(false);
    for (let i = 0; i < blobs.length; i++) {
      if (usados[i]) continue;
      let cur = blobs[i];
      for (let j = i + 1; j < blobs.length; j++) {
        if (usados[j]) continue;
        if (cur.bounds.intersects(blobs[j].bounds) && cur.intersects(blobs[j])) {
          cur = cur.unite(blobs[j]);
          blobs[j].remove();
          usados[j] = true;
        }
      }
      fusionados.push(cur);
      usados[i] = true;
    }
    // Estiliza los fusionados (stroke, sombra, etc.)
    fusionados.forEach(b => {
      b.strokeColor = getComputedStyle(document.documentElement).getPropertyValue("--color-3").trim();
      b.strokeWidth = 8;
      b.shadowColor = new paper.Color(0, 0, 0, 0.22);
      b.shadowBlur = 32;
    });

    paper.view.update();
  }

  // --- 4. RENDERIZA LOS LABELS/PALABRAS ENCIMA DE LAS NUBES ---
  function renderLabels(posiciones) {
    container.innerHTML = "";
    posiciones.forEach(({ top, left, w, h, proyecto }) => {
      // Crea div con tu mismo CSS para nube y label (¡usa tu .nube-box!)
      const nubeDiv = document.createElement('div');
      nubeDiv.className = 'nube-box';
      nubeDiv.style.top = `${top}vh`;
      nubeDiv.style.left = `${left}vw`;
      nubeDiv.style.width = `${w}vw`;
      nubeDiv.style.height = `${h}vh`;
      // Puedes quitar el color de fondo en CSS si solo quieres la nube visual detrás

      // Palabra, con enlace si hay
      const label = document.createElement('div');
      label.className = 'nube-label';
      if (proyecto.links && proyecto.links.length > 0) {
        const a = document.createElement('a');
        a.href = proyecto.links[0];
        a.target = '_blank';
        a.textContent = proyecto.name || proyecto.titulo || 'Sin nombre';
        a.style.color = 'inherit';
        a.style.textDecoration = 'none';
        label.appendChild(a);
      } else {
        label.textContent = proyecto.name || proyecto.titulo || 'Sin nombre';
      }
      nubeDiv.appendChild(label);

      container.appendChild(nubeDiv);
    });
  }

  // --- 5. RENDER PRINCIPAL: DIBUJA Y POSICIONA TODO ---
  let posiciones = calculaPosiciones();
  function renderAll() {
    resizeCanvas();
    renderBlobs(posiciones); // las nubes del canvas (fusionadas)
    renderLabels(posiciones); // las palabras encima, usando tu CSS
  }

  // --- 6. REDIBUJA SOLO (NO REGENERA POSICIONES) AL REDIMENSIONAR ---
  window.addEventListener("resize", () => {
    renderAll();
  });

  // --- 7. ARRANCA ---
  renderAll();

  // --- EXTRA: SI QUIERES REGENERA POSICIONES AL RECARGAR ---
  // window.addEventListener("dblclick", () => { posiciones = calculaPosiciones(); renderAll(); });

});
  </script>

</body>


</html>